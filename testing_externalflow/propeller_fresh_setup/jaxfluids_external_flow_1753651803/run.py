#!/usr/bin/env python3
"""
VectraSim Intelligent Simulation Suite
Adaptive JAX-Fluids Script Generator

Generated for: external_flow (3D)
Simulation Intent: propeller external flow simulation for aerodynamic analysis. Use the custom propeller SDF for 3D external flow around the propeller geometry.
Plotting Mode: research

This script was automatically generated by VectraSim's adaptive agent
based on JAX-Fluids (Apache 2.0 licensed) for computational fluid dynamics.

VectraSim - Advanced Computational Physics Platform
"""

import time
import json
import os

import numpy as np
import matplotlib.pyplot as plt

import jax
import jax.numpy as jnp
from jax import random

from jax_fluids import base, init, physics, boundary, io, visualize, mesh
from jax_fluids.external_flow import external_flow_setup

# --- Configuration ---
CASE_FILE = "case_setup_temp.json"
NUMERICAL_FILE = "numerical_setup_temp.json"
OUTPUT_FOLDER = "output"
QUANTITIES = ['density', 'velocity', 'pressure', 'levelset', 'volume_fraction', 'mach_number', 'schlieren']
CUDA_DEVICE = '0'

# --- Helper Functions ---
def create_output_folder(output_folder):
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)

def save_settings(output_folder, case_settings, numerical_settings):
    with open(os.path.join(output_folder, "case_settings.json"), "w") as f:
        json.dump(case_settings, f, indent=4)
    with open(os.path.join(output_folder, "numerical_settings.json"), "w") as f:
        json.dump(numerical_settings, f, indent=4)

def load_settings(case_file, numerical_file):
    with open(case_file, "r") as f:
        case_settings = json.load(f)
    with open(numerical_file, "r") as f:
        numerical_settings = json.load(f)
    return case_settings, numerical_settings

def post_process(state, params, numerical_settings, output_folder, step):
    """Post-processing and visualization for external flow."""
    grid_size = numerical_settings["grid_size"]
    domain = params["domain"]

    # Extract fields
    density = state.density
    velocity = state.velocity
    pressure = state.pressure
    levelset = state.levelset

    # Compute derived quantities
    mach_number = jnp.linalg.norm(velocity, axis=-1) / params["sound_speed"]
    volume_fraction = jnp.clip(0.5 * (1 + levelset / numerical_settings["levelset_smoothing"]), 0.0, 1.0)

    # Schlieren visualization (example)
    density_gradient_x = jnp.gradient(density, axis=0)
    density_gradient_y = jnp.gradient(density, axis=1)
    density_gradient_z = jnp.gradient(density, axis=2)
    schlieren = jnp.sqrt(density_gradient_x[0]**2 + density_gradient_y[0]**2 + density_gradient_z[0]**2)

    # Visualization
    if 'density' in QUANTITIES:
        visualize.plot_scalar_field(density, domain, grid_size, os.path.join(output_folder, f"density_{step:04d}.png"), title="Density")
    if 'velocity' in QUANTITIES:
        visualize.plot_vector_field(velocity, domain, grid_size, os.path.join(output_folder, f"velocity_{step:04d}.png"), title="Velocity")
    if 'pressure' in QUANTITIES:
        visualize.plot_scalar_field(pressure, domain, grid_size, os.path.join(output_folder, f"pressure_{step:04d}.png"), title="Pressure")
    if 'levelset' in QUANTITIES:
        visualize.plot_scalar_field(levelset, domain, grid_size, os.path.join(output_folder, f"levelset_{step:04d}.png"), title="Levelset")
    if 'volume_fraction' in QUANTITIES:
        visualize.plot_scalar_field(volume_fraction, domain, grid_size, os.path.join(output_folder, f"volume_fraction_{step:04d}.png"), title="Volume Fraction")
    if 'mach_number' in QUANTITIES:
        visualize.plot_scalar_field(mach_number, domain, grid_size, os.path.join(output_folder, f"mach_number_{step:04d}.png"), title="Mach Number")
    if 'schlieren' in QUANTITIES:
        visualize.plot_scalar_field(schlieren, domain, grid_size, os.path.join(output_folder, f"schlieren_{step:04d}.png"), title="Schlieren")

# --- Main ---
def main():
    # 1. Input Manager
    case_settings, numerical_settings = load_settings(CASE_FILE, NUMERICAL_FILE)

    # Set CUDA device
    os.environ["CUDA_VISIBLE_DEVICES"] = CUDA_DEVICE

    # Create output folder
    create_output_folder(OUTPUT_FOLDER)
    save_settings(OUTPUT_FOLDER, case_settings, numerical_settings)

    # 2. Initialization Manager
    key = random.PRNGKey(0)
    params = external_flow_setup.create_params(case_settings, numerical_settings)
    state = init.create_state(key, params, numerical_settings)

    # 3. Simulation Manager
    dt = numerical_settings["dt"]
    num_steps = numerical_settings["num_steps"]
    plot_every = numerical_settings["plot_every"]

    if numerical_settings["viscous"]:
        viscosity_fn = physics.artificial_viscosity
    else:
        viscosity_fn = None

    if numerical_settings["heat"]:
        heat_diffusion_fn = physics.artificial_heat_diffusion
    else:
        heat_diffusion_fn = None

    if numerical_settings["levelset"]:
        levelset_fn = physics.levelset_advection
    else:
        levelset_fn = None

    if numerical_settings["convective"]:
        convective_fn = physics.convective_advection
    else:
        convective_fn = None

    def step(state, params):
        return base.step(state, params, dt, viscosity_fn, heat_diffusion_fn, levelset_fn, convective_fn)

    step = jax.jit(step)

    start_time = time.time()
    for i in range(num_steps):
        state = step(state, params)

        if i % plot_every == 0:
            print(f"Step {i}/{num_steps}")
            post_process(state, params, numerical_settings, OUTPUT_FOLDER, i)

    end_time = time.time()
    print(f"Simulation finished in {end_time - start_time:.2f} seconds.")

if __name__ == "__main__":
    main()